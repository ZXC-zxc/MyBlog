---
layout: post
title:  "Schnorr签名会怎样改进比特币"
date:   2022-10-14 16:09:51 +0800
categories: bitcoin schnorr
usemathjax: true
---

&emsp;&emsp;当我阅读 Blockstream 的 [MuSig](https://eprint.iacr.org/2018/068.pdf) 这篇论文时，我试图想象这对于像我一样的比特币用户意味着什么。我发现 Schnorr 签名的某些特性非常棒且方便，但另一些特性却有些烦人。在这里，我想与你分享我的想法。首先，我们快速回顾一下：  
# **ECDSA签名算法(*Elliptic Curve Digital Signature Algorithm*)**
&emsp;&emsp;当前在比特币中，我们使用 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)来进行签名。为了对消息 ***m*** 进行签名，我们对其进行哈希处理并将此哈希视为一个数字：***z = hash(m)***。我们还需要一个随机或看似随机的数字 ***k***。我们一般不信任随机数生成器（有太多的故障和漏洞与不安全的随机数有关）所以我们通常使用 [RFC6979](https://tools.ietf.org/html/rfc6979) 来根据我们的私钥和我们用来签名的消息来计算出一个确定性的 ***k***值。  
&emsp;&emsp;使用私钥 ***pk***，我们可以为消息 ***m*** 生成一个签名，该签名由两个数字组成：***r***（随机点 ***R=k×G*** 的 ***x*** 坐标 ）和 ***s = (z+r⋅pk)/k***。然后，使用我们的公钥 ***P = pk×G***，任何人都可以通过检查点 ***(z/s)×G+(r/s)×P*** 的 ***x*** 坐标是否等于 ***r*** 来验证我们的签名。
![](../../../../../images/ECDSA.png)
<center><small><i>ECDSA 算法的可视化。出于说明的目的，椭圆曲线绘制在实数上。</i></small></center>  
&emsp;&emsp;这是一个很常见也很棒的算法，但它还可以进行改进。首先，验证签名包括一次求逆***（1/s）***运算和两次点乘运算，这些运算的计算量很大。在比特币中，每个节点都必须验证所有的交易。这意味着当你广播交易时，成千上万的计算机将不得不验证你的签名。使验签过程变得更简单将是一个很有益的改进，即使他会导致签名过程变得更困难。  
&emsp;&emsp;其次，每个节点都必须分别独立的验证每个签名。在使用 m-of-n 这种多重签名交易时，区块链节点甚至可能需要多次验证相同的签名。例如，一笔交易中有一个 7-of-11 的多重签名Input，它里面包含 7 个签名，那么这就需要在网络中的*每个节点*上都要进行 7 到 11 次验签运算。同时，此类交易将占用区块中的大量的空间，你将不得不为此支付高昂的手续费。
# **Schnorr 签名**
&emsp;&emsp;Schnorr 签名的生成方式略有不同。我们使用点 ***R*** 和标量 ***s*** 代替两个标量 ***(r,s)***来表示签名。与 ECDSA 类似，***R*** 是椭圆曲线上的一个随机点***（R = k×G）***。签名的第二部分的计算方式则略有不同：***s = k + hash(P,R,m) ⋅ pk***。这里 ***pk*** 是你的私钥，***P = pk×G*** 是你的公钥，***m*** 是消息。然后可以通过检查 ***s×G = R + hash(P,R,m)×P*** 来验证这个签名。  
![](../../../../../images/schnorr.png)
<center><small><i>Schnorr 算法的可视化示意图。</i></small></center>  
&emsp;&emsp;这个方程是线性的，所以方程和方程之间是可以进行相加和相减操作的，并且会保证进行加减后的方程仍然有效。Schnorr 签名的这种特性，将为我们带来了几个不错的新功能。  
#### **1.批量验证**
&emsp;&emsp;为了验证比特币区块链中的区块，我们需要确保区块中的所有签名都是有效的。如果其中一个无效，我们不在乎是哪一个——我们将会拒绝整个区块。  
&emsp;&emsp;当使用ECDSA签名时，每个签名都必须单独验证。这意味着如果我们在区块中有 1000 个签名，我们将需要运行 1000 次求逆运算和 2000 次点乘运算，总共 3000 次的大计算量的运算。  
&emsp;&emsp;当使用Schnorr签名时，我们可以将所有签名验证方程相加来节省一些计算能力。对于一个有 1000 笔交易的区块，我们需要验证：  
***(s1+s2+…+s1000)×G=(R1+…+R1000)+(hash(P1,R1,m1)×P1+ hash(P2,R2,m2)×P2+…+hash(P1000,R1000,m1000)×P1000)***  
&emsp;&emsp;在这里，我们有一堆点加法（这对于计算机来说几乎是没有什么计算量的）和 1001 次点乘法。相比较ECDSA这已经是 3 倍的改进了——我们只需要为每个签名进行1次大计算量的操作。![](../../../../../images/schnorr_batch.png)
<center><small><i>两个签名的批量验证图示。由于验证方程是线性的，只要所有签名都有效，几个方程的总和就有效。我们节省了一些计算能力，因为标量和点加法比点乘法容易计算得多。</i></small></center>  
#### **2.密钥聚合**
&emsp;&emsp;如果我们想要确保所持有的比特币不被盗取，我们可能会想到要使用至少两个不同的私钥来保护比特币。我们将在笔记本电脑或手机上使用一个，另一个则在硬件钱包/冷钱包上使用。因此，当其中一个泄露时，我们仍然可以保证我们的比特币不被盗取。  
&emsp;&emsp;目前这种想法是通过 2-of-2 multisig 脚本实现的。这需要在交易中包含两个单独的签名。  
&emsp;&emsp;当使用 Schnorr 签名时，我们可以使用一对私钥 ***(pk1,pk2)*** 来生成对应于聚合公钥 ***P=P1+P2=pk1×G+pk2×G*** 的聚合签名。要生成这个签名，我们需要在每个设备上选择一个随机数 ***(k1,k2)***，再生成一个随机点***Ri=ki×G***，将它们加起来计算一个公共哈希 ***hash(P,R1+R2,m)***，然后得到每个设备的 ***s1*** 和 ***s2 (si = ki + hash(P,R,m) ⋅ pki)***。然后我们可以将这些签名相加，并使用一对 ***(R, s) = (R1+R2, s1+s2)*** 作为我们对聚合公钥 ***P*** 的签名。其他人将无法判断它是否是一个聚合签名——因为它看起来与正常的 Schnorr 签名完全相同。  
&emsp;&emsp;这种方案设计存在三个问题。第一个——从 UI 的角度来看。为了进行交易，我们需要先进行几轮通信来计算公共的***R***，然后再进行签名。在使用两个私钥进行聚合的时候，我们可以通过访问一次冷钱包来完成：我们在我们的在线钱包上准备一个未签名的交易，选择 ***k1*** 并写下 ***R1=k1×G*** 。然后我们将这些数据和未签名交易一起传递到冷钱包并签名。由于我们已经有了 ***R1***，我们可以一次性的在冷钱包上交易签名。从冷钱包中我们得到 ***R2*** 和 ***s2***，我们将它们传回在线钱包。在线钱包使用先前选择的 ***(k1, R1)*** 对交易进行签名，聚合签名并广播已签名的交易。这与我们现在所用的流程的非常相似，但是一旦你添加了第三个私钥，一切都会变得复杂起来。想象一下，你有一笔资产，由存储在世界各地不同安全地点的 10 个私钥控制。假如你现在需要进行交易，用现有的方案，你只需要遍历所有这些地方一次，但如果你使用密钥聚合方案，你需要这样做两次——因为你需要先获取所有的 ***Ri***，然后再签名。在这种情况下，最好使用单独的签名而不是进行聚合签名——这样就只需要一轮遍历。  
后续更新，感谢 Manu Drijvers 提出这一点：对于可证明安全的多重签名方案，你需要 3 轮通信：
* 选定一个随机数**ki**，计算对应的**Ri=ki×G**，只告诉大家它的哈希**ti=hash(Ri)**，这样大家就可以通过这个承诺确定你在拿到了别人的随机数后不会改变你自己的随机数。
* 将所有参与方的 **Ri** 收集在一起并计算公共 **R**
* 签名  

&emsp;&emsp;第二个问题是已知的恶意密钥攻击(*Rogue key attack*)。它在[这篇论文](https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1)里有很好的描述，所以我不会去详细的说明。它的核心思路是，如果你的一个设备被黑客入侵（例如，你的在线钱包）并假装其公钥是***(P1-P2)***，那么它就可以使用其私钥 ***pk1*** 来控制共享资产。一个简单的解决方案是：在我们开始设置设备时，我们会额外要求相应的设备使用其私钥对公钥进行签名。  
&emsp;&emsp;还有第三个重要问题。**你将不能使用确定性 k值来进行签名**。如果你使用确定性 k值，则会有一个简单的攻击方法，允许黑客获取我们的私钥。这个攻击看起来是像这样：有人入侵了我们的笔记本电脑，并完全控制了两个私钥之一（例如，***pk1***）。我们不会担心资产安全受到威胁，因为我们的比特币需要 ***pk1*** 和 ***pk2*** 的聚合签名。所以我们试图像往常一样进行交易，准备一个未签名的交易和 ***R1*** 值，将它们发送到我们的硬件钱包并在那里签名，然后将***(R2, s2)***传回来。再之后......我们的在线钱包发生了一些问题，它无法签名和广播了。我们尝试着再做一次，但我们被黑的计算机这次使用了另一个随机值——***R1'***。我们再次使用我们的硬件钱包签署相同的交易并将值***（R2，s2'）***带回我们被黑客入侵的计算机。 哦天啊，悲剧发生了，我们丢失了所有的比特币。  
&emsp;&emsp;在这种攻击时，黑客获取同一笔交易的两个有效的签名：***(R1, s1, R2, s2)*** and ***(R1', s1', R2, s2')***。在这里***R2***是相同的，但 ***R = R1+R2*** 和 ***R'=R1'+R2*** 不同。这意味着黑客可以计算出我们的第二个私钥：由***s2-s2'=(hash(P,R1+R2,m)-hash(P,R1'+R2,m))⋅pk2*** 推导出***pk2=(s2-s2 ')/(hash(P,R1+R2,m)-hash(P,R1'+R2,m))***。我发现这是密钥聚合最不方便的一个特性——我们需要在任何地方使用一个好的随机数生成器来使用密钥聚合。
#### **3.多重签名**  
&emsp;&emsp;[MuSig](https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html) 解决了其中一个问题——它使得恶意密钥攻击成为不可能。它的目标是将来自多方或多个设备的签名和公钥聚合到一个，同时不需要证明你拥有与公钥对应的私钥。  
&emsp;&emsp;聚合签名类似于聚合公钥。但是，我们不只是将所有共同签名者的公钥相加，而是将它们乘以某个因子。聚合的公钥将是 ***P=hash(L,P1)×P1+…+hash(L,Pn)×Pn***。这里 ***L=hash(P1,…,Pn)*** — 一个由所有公钥计算出的公共数字。这种非线性的特性可以有效防止攻击者像在恶意密钥攻击中那样构造出恶意的公钥。即使攻击者确切地知道他的 ***hash(L,Patk)×Patk*** 应该是什么，他也无法从中导出 ***Patk***——这与从公钥中导出私钥是相同的数学问题。  
&emsp;&emsp;其余的部分与之前的方案非常相似。为了生成签名，每个共同签名者选择一个随机数 ***ki*** 并与其他人共享 ***Ri=ki×G***。然后他们将所有这些随机点加起来成为一个单个的点 ***R=R1+…+Rn*** 并生成签名 ***si = ki + hash(P,R,m) ⋅ hash(L,Pi) ⋅ pki***。聚合签名为***(R, s)=(R1+…+Rn, s1+…+sn)***，验证方程同上：***s×G = R + hash(P,R,m)×P***。
#### **4.默克尔多签(*Merkle Multisig*)**
&emsp;&emsp;你可能已经注意到，MuSig的密钥聚合会要求所有合作签名者都要参与交易签名。但是，如果你想发起一个 2-of-3 多重签名怎么办？在这种情况下是否可以使用签名聚合，或者我们将不得不使用我们现在常用的 OP_CHECKMULTISIG 和一个个独立的签名？是的，这虽然是可以的。但是如果我们对协议进行一点点改变，我们就可以开发一个类似于 OP_CHECKMULTISIG 的新op-code，它用于检查最终聚合的签名对应的公钥是否是 公钥Merkle树（*Merkle tree of public keys*）中的某一个特定项。  
&emsp;&emsp;比如，如果我们使用公钥 ***P1***、***P2*** 和 ***P3*** 来进行 ***2-of-3*** 的多重签名，那么我们需要使用所有可能的组合构建一个公钥Merkle 树：***(P1, P2), (P2, P3), (P1, P3)*** 并将Merkle根放在锁定脚本中。当花费比特币时，我们需要提供签名和我们的公钥在树中的证明。对于 ***2-of-3*** 多重签名，树中只有 3 个元素，证明将包含两个哈希值 - 我们要使用的哈希值和它相邻的哈希值。对于 ***7-of-11*** 的多重签名，将有 ***11!/7!/4!=330*** 个可能的密钥组合，证明则需要 ***8*** 个元素。一般来说，证明中的元素数量几乎与 multisig 中的密钥数量成线性关系（它的公式是***log2(n!/m!/(n-m)!***）。  
&emsp;&emsp;但是对于公钥Merkle树，我们不仅限于使用在 ***m-of-n*** 的多重签名中。我们可以用我们指定的任何公钥来制作一棵树。例如，如果我们有一台笔记本电脑、一部手机、一个硬件钱包和一个恢复种子（*recovery seed*）。我们可以通过构建这样结构的一棵树，来允许我们用笔记本电脑和硬件钱包的组合或是手机和硬件钱包的组合亦或是仅通过恢复种子这三种方式来花费比特币。当前仅使用 OP_CHECKMULTISIG 是做不到的——只有当你用分支或者其他东西来构造更复杂的脚本时，才有可能做到。  
![](../../../../../images/MerkleTreeSign.png)
<center><small><i>聚合公钥的Merkle树，比多重签名更强大</i></small></center> 
#### **结论**
&emsp;&emsp;Schnorr签名很棒。它们可以在区块验证期间节省一些计算能力，还可以让我们使用密钥聚合。最后虽然还有一些不便，但我们并没有被迫使用它们——毕竟，如果我们愿意，我们可以继续使用独立的、非聚合签名的普通多重签名方案。我迫不及待地想开始使用它们，我希望它们很快就会被包含在比特币协议中。  
&emsp;&emsp;我真的很喜欢这篇[论文](https://eprint.iacr.org/2018/068.pdf)，MuSig 方案很聪明，而且论文本身很容易阅读。如果你有时间，我强烈建议你看一下。  
&emsp;&emsp;P.S. 还有另一种也非常棒的签名类型——BLS 签名。从某种意义上说，它们看起来甚至比 Schnorr 还要好。如果您想知道 BLS 签名是关于什么的，请关注我的下一篇[文章](https://medium.com/@snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716)。

本文翻译自：
https://medium.com/cryptoadvance/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744

