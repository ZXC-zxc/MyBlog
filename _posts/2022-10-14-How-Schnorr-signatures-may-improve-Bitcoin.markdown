---
layout: post
title:  "Schnorr签名会怎样改进比特币"
date:   2022-10-14 16:09:51 +0800
categories: bitcoin schnorr
usemathjax: true
---

&emsp;&emsp;当我阅读 Blockstream 的 [MuSig](https://eprint.iacr.org/2018/068.pdf) 这篇论文时，我试图想象这对于像我一样的比特币用户意味着什么。我发现 Schnorr 签名的某些特性非常棒且方便，但另一些特性却有些烦人。在这里，我想与您分享我的想法。首先，我们快速回顾一下：  
# **ECDSA签名算法(*Elliptic Curve Digital Signature Algorithm*)**
&emsp;&emsp;当前在比特币中，我们使用 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)来进行签名。为了对消息 ***m*** 进行签名，我们对其进行哈希处理并将此哈希视为一个数字：***z = hash(m)***。我们还需要一个随机或看似随机的数字 ***k***。我们一般不信任随机数生成器（有太多的故障和漏洞与不安全的随机数有关）所以我们通常使用 [RFC6979](https://tools.ietf.org/html/rfc6979) 来根据我们的私钥和我们用来签名的消息来计算出一个确定性的 ***k***值。  
&emsp;&emsp;使用私钥 ***pk***，我们可以为消息 ***m*** 生成一个签名，该签名由两个数字组成：***r***（随机点 ***R=k×G*** 的 ***x*** 坐标 ）和 ***s = (z+r⋅pk)/k***。然后，使用我们的公钥 ***P = pk×G***，任何人都可以通过检查点 ***(z/s)×G+(r/s)×P*** 的 ***x*** 坐标是否等于 ***r*** 来验证我们的签名。
![](../../../../../images/ECDSA.png)
<center><small><i>ECDSA 算法的可视化。出于说明的目的，椭圆曲线绘制在实数上。</i></small></center>  
&emsp;&emsp;这是一个很常见也很棒的算法，但它还可以进行改进。首先，验证签名包括一次求逆***（1/s）***运算和两次点乘运算，这些运算的计算量很大。在比特币中，每个节点都必须验证所有的交易。这意味着当你广播交易时，成千上万的计算机将不得不验证你的签名。使验签过程变得更简单将是一个很有益的改进，即使他会导致签名过程变得更困难。  
&emsp;&emsp;其次，每个节点都必须分别独立的验证每个签名。在使用 m-of-n 这种多重签名交易时，区块链节点甚至可能需要多次验证相同的签名。例如，一笔交易中有一个 7-of-11 的多重签名Input，它里面包含 7 个签名，那么这就需要在网络中的*每个节点*上都要进行 7 到 11 次验签运算。同时，此类交易将占用区块中的大量的空间，你将不得不为此支付高昂的手续费。
# **Schnorr 签名**
&emsp;&emsp;Schnorr 签名的生成方式略有不同。我们使用点 ***R*** 和标量 ***s*** 代替两个标量 ***(r,s)***来表示签名。与 ECDSA 类似，***R*** 是椭圆曲线上的一个随机点***（R = k×G）***。签名的第二部分的计算方式则略有不同：***s = k + hash(P,R,m) ⋅ pk***。这里 ***pk*** 是你的私钥，***P = pk×G*** 是你的公钥，***m*** 是消息。然后可以通过检查 ***s×G = R + hash(P,R,m)×P*** 来验证这个签名。  
![](../../../../../images/schnorr.png)
<center><small><i>Schnorr 算法的可视化。</i></small></center>  
&emsp;&emsp;这个方程是线性的，所以方程可以进行相加和相减操作，并且会保证进行加减后的方程仍然有效。Schnorr 签名的这种特性，将为我们带来了几个不错的新功能。  
#### **1.批量验证**
&emsp;&emsp;为了验证比特币区块链中的区块，我们需要确保区块中的所有签名都是有效的。如果其中一个无效，我们不在乎是哪一个——我们将会拒绝整个区块。  
&emsp;&emsp;当使用ECDSA签名时，每个签名都必须单独验证。这意味着如果我们在区块中有 1000 个签名，我们将需要运行 1000 次求逆运算和 2000 次点乘运算，总共 3000 次的大计算量的运算。  
&emsp;&emsp;当使用Schnorr签名时，我们可以将所有签名验证方程相加来节省一些计算能力。对于一个有 1000 笔交易的区块，我们需要验证：  
***(s1+s2+…+s1000)×G=(R1+…+R1000)+(hash(P1,R1,m1)×P1+ hash(P2,R2,m2)×P2+…+hash(P1000,R1000,m1000)×P1000)***  
&emsp;&emsp;在这里，我们有一堆点加法（这对于计算机来说几乎是没有什么计算量的）和 1001 次点乘法。相比较ECDSA这已经是 3 倍的改进了——我们只需要为每个签名进行1次大计算量的操作。![](../../../../../images/schnorr_batch.png)
<center><small><i>两个签名的批量验证图示。由于验证方程是线性的，只要所有签名都有效，几个方程的总和就有效。我们节省了一些计算能力，因为标量和点加法比点乘法容易计算得多。</i></small></center>  
#### **2.密钥聚合**
&emsp;&emsp;如果我们想要确保所持有的比特币不被盗取，我们可能会想到要使用至少两个不同的私钥来保护比特币。我们将在笔记本电脑或手机上使用一个，另一个则在硬件钱包/冷钱包上使用。因此，当其中一个泄露时，我们仍然可以保证我们的比特币不被盗取。  
&emsp;&emsp;目前它是通过 2-of-2 multisig 脚本实现的。这需要在交易中包含两个单独的签名。  
&emsp;&emsp;当使用 Schnorr 签名时，我们可以使用一对私钥 ***(pk1,pk2)*** 来生成对应于共享公钥 ***P=P1+P2=pk1×G+pk2×G*** 的共享签名。要生成这个签名，我们需要在每个设备上选择一个随机数 ***(k1,k2)***，再生成一个随机点***Ri=ki×G***，将它们加起来计算一个公共哈希 ***(P,R1+R2,m)***，然后得到每个设备的 ***s1*** 和 ***s2 (si = ki + hash(P,R,m) ⋅ pki)***。然后我们可以将这些签名相加，并使用一对 ***(R, s) = (R1+R2, s1+s2)*** 作为我们对共享公钥 ***P*** 的签名。其他人将无法判断它是否是一个聚合签名——因为它看起来与正常的 Schnorr 签名完全相同。