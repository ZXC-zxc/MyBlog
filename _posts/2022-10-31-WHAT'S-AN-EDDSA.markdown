---
layout: post
title:  "什么是EdDSA算法"
date:   2022-10-31 16:09:51 +0800
categories: eddsa ed25519
usemathjax: true
---
## **00.基本介绍**

&emsp;&emsp;EdDSA 是一种基于 [Schnorr签名](https://en.wikipedia.org/wiki/Schnorr_signature) 实现的数字签名方案，它在椭圆曲线上运行。虽然 ECDSA 可能是部署最广泛的椭圆曲线数字签名方案，但 EdDSA 具有许多特性，使其成为比 ECDSA 更有吸引力的替代方案。在本技术性的说明中，我们旨在回答“什么是 EdDSA 以及它是如何工作的？”这个问题。本文是特别技术说明系列的一部分，该系列专注于解释各种有趣的密码学花絮。您还可以查看我们对 [2P-ECDSA（两方协同ECDSA算法）](https://duo.com/labs/tech-notes/2p-ecdsa-explained)、ECDSA门限算法的探索，或我们对[噪声协议框架(Noise protocol framework)](https://duo.com/labs/tech-notes/noise-protocol-framework-intro)的介绍。  
&emsp;&emsp;我们假设你对椭圆曲线密码学有一定的了解，如果你想复习一下，建议你阅读 [Nick Sullivan 的椭圆曲线密码学简介](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)。我们将讨论用于生成和验证 EdDSA 签名的算法以及它们背后的一些数学知识，但更深入地了解该方案为何安全则需要更多的代数知识，这暂时不在本文的介绍范围之内。  
&emsp;&emsp;最后，还有一些 EdDSA 特有的细微点，例如曲线点的编码和我们在本文中完全省略掉的上下文的使用。如果你对这些更详细的细节感兴趣，我建议您阅读 [RFC](https://tools.ietf.org/html/rfc803) 以及 [ed25519-dalek](https://github.com/dalek-cryptography/ed25519-dalek) 的源代码，这是一个Ed25519 的 Rust 实现。
## **01.谁定义的区线？**
&emsp;&emsp;EdDSA的规范是[RFC 8023](https://tools.ietf.org/html/rfc8032)。它允许你对其参数进行调整：不同的曲线、不同的哈希函数以及各种有趣的东西。我将特别关注一个名为 Ed25519 的 EdDSA 实例，它在 **edwards25519** 曲线上运行。RFC 中描述了 EdDSA 的两个特定实例：Ed25519 和 Ed448。 Ed25519 是你在现实中最有可能用到的（例如，作为 ssh-keygen -t 的一个选项。）  
&emsp;&emsp;RFC 中列出了 EdDSA的以下优势：
* 在多个平台上都是高效的
* 不需要每个签名均使用唯一的随机数（避免类似于在PS3上出现的问题，重复使用的随机数暴露了索尼的签名密钥）
* 可抵御侧信道攻击
* 较小长度的公钥和签名（在Ed25519 中分别为 32 和 64 字节）
* 公式对曲线上的所有点都有效，无一例外
* 可抵御碰撞  

## **02.难以解决的离散对数问题**
&emsp;&emsp;密码学之所以行之有效，是因为有些数学问题很难解决。在经典的 RSA 算法中，我们所依赖的问题是怎样分解两个大素数的乘积。而在椭圆曲线世界中，我们所依赖的问题则是离散对数问题。  
&emsp;&emsp;在椭圆曲线上，有一个基本前提：如果我取一个标量值 ***x***，计算 ***Q = x * G***（其中 ***Q*** 和 ***G*** 是曲线上的点），即使你知道 ***Q*** 和 ***G***，你也没有办法可以计算出***x***。如果我已经知道 ***x*** 和 ***G***，那么计算 ***Q*** 对我来说很容易，但是你即使运行你的笔记本电脑直到宇宙爆炸，你也不可能只用***Q*** 和 ***G*** 计算出到 ***x***。Nick Sullivan 在他对[椭圆曲线密码学的介绍文章](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)中给出了一个“台球(*billiards*)”类比。  
&emsp;&emsp;在 EdDSA 中我们也使用了一个类似但并不一样的难题：假设我给你 ***z*** 和 ***p*** 其中 ***z = (a + bx) mod p*** （这次使用的是整数模素数的方法），只要 ***a*** 是随机的，即使你知道 ***b*** ，你在恒星消失之前也无法恢复 ***x***（假设 ***p*** 是一个足够大的素数）。这基于一个（可证明的）事实，即：如果 ***a mod p*** 是均匀分布的，则 ***(a + bx) mod p*** 也将是均匀分布的，因此不会泄露任何关于 ***x*** 的信息。  
## **03.EdDSA曲线参数**
&emsp;&emsp;你也许可以跳过本节，但为了完整起见，这里列出了用于 EdDSA 的 11 个参数！（里面并没有包含曲线的选择）：
* 奇素数 ***p***——EdDSA 在有限域 ***GF(p)*** 上使用椭圆曲线
* 使得 ***2^(b-1) > p*** 的整数 ***b*** —— EdDSA 公钥具有 ***b*** 位、签名具有 ***2b*** 位
* 有限域 ***GF(p)*** 中元素的 ***(b-1)*** 位编码
* 一个产生 ***2 * b*** 位输出的具有密码学安全强度的哈希函数
* 一个是***2*** 或是 ***3*** 的整数 ***c*** —— EdDSA 的私钥是 ***2^c*** 的倍数
* 一个整数***n***，保证***c <= n < b***
* 一个***GF(p)***中的二次非剩余数(*non-square element*)***d***
* 一个非0的二次剩余数***a***
* 元素***B***，也是曲线的基点
* 一个奇素数***L***，它满足***L * B=0***，并且***2^c * L = #E***，其中***#E***是曲线上点的数量
* 一个预哈希函数 ***PH***  

## **04.Ed25519**
&emsp;&emsp;Ed25519 使用 [RFC 7748]((https://tools.ietf.org/html/rfc7748)) 中定义的曲线参数进行实例化。你可以在 [RFC 8023](https://tools.ietf.org/html/rfc8032#section-5.1) 的第 5.1 节列找出的完整的参数列表，但这里有一些你可能想知道的更重要的参数：
* ***b = 256***,所以Ed25519的公钥是256比特的，而签名值是512比特的。
* ***H(x) = SHA-512(x)***  

#### **密钥**
&emsp;&emsp;Ed25519 私钥是 256 位加密安全随机数据。这里没有什么特殊生成技术。
而公钥***A***（基于私钥secret）生成如下：
```c
//prefix 是高32bytes(原文是bits，应该是一处错误), h是低32bytes
prefix, h = SHA-512(secret)
// 将 h 视为 little-endian 整数，
//设置和清除一些高/低位。具体细节请参见 RFC
s = mangle(h)
A = s * B
// 标量 s 乘以基点 B
// 或者换一种看待它的方式：B 叠加自身 s 次
```
&emsp;&emsp;规范中提出了一种对曲线上的点进行编码的特殊方法，但现在只需了解***h*** 是私钥的SHA-512 哈希值的一部分，***s*** 是标量，***A*** 是由 ***s * B*** 计算出的曲线上的点。我们稍后将在签名过程中使用***prefix***。我们先不深入研究标量 ***s*** 的“重新整理(*mangle*)”的过程，但可以说重整步骤主要是为了避免[小子群攻击(*small-subgroup attacks*)](https://safecurves.cr.yp.to/twist.html)。

#### **签名**
&emsp;&emsp;我们有一条要签名的消息 ***M***。我们用私钥对其签名，它应该可以用公钥***A***验证。我们将产生签名***（R，S）***，验证者最终将检查***S * B = R + k * A***是否为真（稍后会详细介绍——请继续阅读）。  
&emsp;&emsp;将私钥哈希后生成 ***h*** 和 ***prefix***，再构造出私密标量 ***s***，并计算对应的公钥 ***A***，如上文“***密钥***”部分所述。  
&emsp;&emsp;我们将在创建签名的过程中计算两个新的与消息相关的值：***r*** 和 ***k***。 ***r*** 是使用消息计算的确定性消息随机数，***k*** 是从消息内容（和其他的一些数据一起）中派生的哈希值，这两个值帮助我们将最终的签名值对应到我们正在签署的特定消息上。我们将暂时忽略这些值是如何计算的，转而专注于他们本身，以及他们提供的特有属性。  
&emsp;&emsp;首先我们计算 ***r***值，我们的确定性消息随机数。该值将被视为私密的：如果验证者能够预测***r***，那么验证者就能够提取用于签名的密钥。  
&emsp;&emsp;我们计算 ***R = r * B***。就像我们可以通过将标量乘以基点以将私密标量变成公共曲线点一样，我们将消息 ***nonce*** 变成公共点。 ***R*** 的内容不会泄露 ***r*** 的内容。  
&emsp;&emsp;接下来我们计算 ***k***值，一个从消息 ***M*** 派生的哈希值。这个值不是私密的，它将由验证者重新派生。  
&emsp;&emsp;计算 ***S***（尽管它是大写的，但它其实是一个整数），公式为 ***S = (r + k * s) mod L***。着重说一下，***r*** 是我们的确定性消息随机数，***k*** 是我们刚刚计算的消息哈希，***s***是秘密标量（真实私钥进行哈希和重新整理之后的那个值）。我们可以在 ***S*** 的定义中看到， ***r***是被用于“隐藏”密钥的值。正如我们在“难题”一节中提到的，攻击者可以知道 ***S、k***和 ***L***，但只要 ***r*** 是均匀分布的，就很难恢复出 ***s***。  
&emsp;&emsp;***(R, S)*** 对是最终的签名。我将再次指出这个符号上的怪异之处：***R*** 是曲线上的点，但 ***S*** 是整数。
#### **验签**
&emsp;&emsp;验证者想要确认签名 ***(R, S)***是消息 ***M*** 由用户使用公钥***A*** 对应的私钥签署的。明确一下，验证者也知道曲线参数，因此它知道基点 ***B***。  
&emsp;&emsp;验证者重新计算签名者使用的 ***k*** 值，然后检查 ***S * B = R + k * A***是否成立。如果这两个值相等，则签名有效。 这其中***R*** 和 ***S*** 是签名者提供的签名值，***B*** 是双方都知道的公共基点，***A*** 是签名者的公钥，***k*** 是消息哈希。  
##### **这是怎么运算的呢？**
&emsp;&emsp;这是个好问题。让我们看看这些值的定义，看看我们是否能搞清楚。如果你熟悉椭圆曲线密码学，这里的核心技术可能很熟悉：验证者无法访问任何签名者的私密信息，但它确实可以访问一些私密信息乘以基点后的信息。  
***S * B = R + k * A***  
&emsp;&emsp;这是当且仅当签名有效时成立的等式。让我们看看等式的 ***S * B*** 侧并将其进行公式转换：  
***S * B
= (r + k * s) * B***  
&emsp;&emsp;在这里，我们仅仅是用定义替换了 ***S***。 ***r*** 和 ***s*** 的值对于验证者来说是未知的，但是通过将 ***S*** 乘以 ***B***，我们可以将 ***S * B*** 变成验证者知道的两个值。  
***(r + k * s) * B
= (r * B) + (k * s * B)***  
&emsp;&emsp;没有 ***r***，我们无法计算 ***r * B***，但我们却已经知道了结果：签名者将其作为 ***R*** 提供给了我们。我们无法以直接的方式计算 ***k * s * B***，因为我们不知道 ***s***，但是签名者的公钥 ***A*** 定义为 ***s * B***。  
将这些元素集合在一起，我们得到：  
***S * B  
= (r + k * s) * B  
= (r * B) + (k * s * B)  
&nbsp;&nbsp;&nbsp;&nbsp;\\___/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\___/  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A  
= R + k * A***  
&emsp;&emsp;简而言之，签名者必须知道私密值 ***r*** 和 ***s*** 才能生成 ***S***——但是我们将 ***S*** 与基点 ***B*** 结合后并进行公式转换，以便我们可以使用公共信息来验证签名的真实性。 
## **05.r和k是怎么构建的，它又为什么很重要？**
&emsp;&emsp;到目前为止，我们只提到了 ***r*** 是一个确定性随机数，***k*** 是从签名消息派生的哈希值。现在我们将更多地讨论这些值是如何生成的，以及每个值的特有属性。  
&emsp;&emsp;***r*** 定义为 ***SHA-512（prefix || M）***，其中***M*** 是要签名的消息。***r***的定义中包含消息***M***以确保 ***nonce*** 是确定性的，因此相同的 ***nonce*** 永远不会用于两个不同的消息。  
&emsp;&emsp;其他一些签名方案，例如 ECDSA，会使用随机数。当使用相同的随机值对两个不同的消息进行签名时，将会引发这些系统的灾难性故障。如果使用良好的随机数发生器，这应该是不会发生的，但索尼泄露 PS3 的签名密钥却正是这个问题造成的，在协议层面就使用确定性随机数会避免这种问题的发生。除了随机数是确定性的之外，对于签名者以外的任何一方来说它仍然是完全不可预测的。将***prefix***（即私钥哈希的一部分）合并到 ***r*** 中可确保任何一方都无法在不知道签名者私钥的情况下计算特定消息的 ***r***。  
&emsp;&emsp;***k*** 的定义是 ***SHA-512(R || A || M)***。  
***k*** 在其定义中使用了***M***，来将签名绑定到特定的消息。验证者将仅使用公共信息来重新推导 ***k***。如果消息在传输过程中被修改（被攻击者或仅仅是传输错误），验证者将计算出不同的 ***k*** 值，而且签名验证也不会成功。  
&emsp;&emsp;***k*** 也是从 ***R*** 和 ***A*** 派生的。将***k***对应到特殊的***R***值是 Fiat-Shamir 转换，但更简单地说，它可以防止恶意方在没有签名者私钥的情况下生成有效签名。我们可以对验证方程进行一些公式转换来证明这一点：  
***S * B = R + k * A  
R = (S * B) - (k * A)***  
如果此处的 ***k*** 值不依赖于 ***R***，则攻击者可以使用任意值来作为***S***并生成具有上述定义的有效***R***。  
&emsp;&emsp;回顾我们的定义，***r*** 是我们的消息 nonce（它是确定性但却是“随机”的，并且对签名者来说也是私有的），而 ***R = r * B*** 则是我们对值 ***r***值的“承诺”。只要要求签名者在生成 ***S*** 之前先决定一个 ***R***，签名者就必须在知道 ***r*** 和 ***s*** 的情况下才能计算 ***S = (r + k * s) mod L***。没有这些信息的冒名者将无法使用上面的等式计算出看似有效的 ***R*** 值。将 ***R*** 参与到 ***k***的运算中，然后将***k***用于 ***S*** 的定义，这样就确保了 ***R*** 不会包含 ***S*** 的先验信息(*prior knowledge*)，因为用于生成 ***k*** 的哈希函数根据定义是单向函数。  
&emsp;&emsp;如果我们在不包含 ***R*** 的情况来计算***k***，恶意方将能够为任意消息与任意公钥生成看起来有效的签名。  
&emsp;&emsp;在 ***k*** 的定义中包含 ***A***会将签名绑定到特定的公钥。这虽然是一个不太重要的属性，但可以防止在某些情况下，有效的签名被修改之后，成为不同（但不是任意）的公钥有效签名。  
## **06.总结一下**
&emsp;&emsp;正如引言中提到的，我们在本文中忽略了一些细节。如果您想了解有关 EdDSA 的更多信息，请查看 RFC 并阅读 [ed25519-dalek](https://github.com/dalek-cryptography/ed25519-dalek) 源代码。  
&emsp;&emsp;EdDSA 的使用不如 ECDSA 广泛，但由于介绍中列举的优势而受到关注。 EdDSA 非常快，会生成较小密钥和签名，并避免了 nonce 重用的可能性。然而，nonce 重用的问题并不是非黑即白的：确定性签名 nonce 可能带来另一些攻击，同时ECDSA 也完全可以与确定性 nonce 一起使用（参见 [RFC 6979](https://tools.ietf.org/html/rfc6979)）。  
&emsp;&emsp;ECDSA 可能会在一段时间内仍然是最常用的椭圆曲线数字签名方案，尤其是硬件对 ECDSA 的支持变得越来越普遍。 在硬件资源更受限的情况下，可以将EdDSA集成到系统中，以将它利用在更现代化的算法系统中。如果您有兴趣，这里有一个[Ed25519 的支持列表](https://ianix.com/pub/ed25519-deployment.html)。  

本文翻译自：  
https://duo.com/labs/tech-notes/whats-an-eddsa