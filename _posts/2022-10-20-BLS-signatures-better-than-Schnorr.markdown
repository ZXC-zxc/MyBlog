---
layout: post
title:  "比Schnorr签名更棒——BLS签名"
date:   2022-10-19 16:09:51 +0800
categories: bitcoin schnorr BLS
usemathjax: true
---
&emsp;&emsp;在上一篇[文章](https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744)[*翻译*](https://zxc-zxc.github.io/MyBlog/bitcoin/schnorr/2022/10/14/How-Schnorr-signatures-may-improve-Bitcoin.html)中，我写了关于 Schnorr 签名以及它有多棒的文章。这篇文章是关于 BLS签名的[(*Boneh-Lynn-Shacham*)](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf)，本文会介绍关于它的一些[非常好的功能](https://eprint.iacr.org/2018/483.pdf)，这些功能是Schnorr签名无法实现的。  
现在，我们知道了如下几点：
 
&emsp;&emsp;ECDSA 签名没问题，它做到了它的工作，并且做得挺好，但仅此而已。我们不能进行聚合签名或聚合密钥，每个签名都必须独立验证。对于多重签名交易，它变得特别的烦人。我们必须一一检查所有的签名和对应的公钥，它会在一个区块中浪费大量空间并需要我们支付高昂的手续费。  
&emsp;&emsp;Schnorr 签名很棒——如果我们正确的使用它的话，我们可以将交易中的所有签名和公钥组合成一个密钥和一个签名，没有人会发现它们其实对应了多个密钥。区块验证也可以更快——我们可以一次验证所有签名。不过有几个问题：

* 多重签名方案需要几轮通信。这对于使用冷存储的人来说可能非常烦人。
* 使用签名聚合时，我们必须依赖随机数生成器——我们不能像在 ECDSA 中那样确定性地选择随机点 ***R***。
* m-of-n 多重签名方案很棘手——我们需要创建一个公钥默克尔树，对于较大的 m 和 n，它会变得相当大。
* 我们不能将区块中的所有签名组合成一个签名。  
  
&emsp;&emsp;BLS签名可以解决以上所有的问题。我们根本不需要随机数，区块中的所有签名可以组合成一个签名，m-of-n 多重签名非常简单，我们不需要合作签名者之间进行几轮通信。此外，BLS 签名比 Schnorr 或 ECDSA 短 2 倍——签名不是一对值，而是单个曲线点。这听起来很神奇！让我们看看它是如何工作的。  

### **BLS签名的魔法**
&emsp;&emsp;在我们开始之前，我们需要先了解两个新的知识——哈希到(曲线上的)点(*hashing to the curve*)和曲线配对(*curves pairing*)。 
#### **哈希到点** 
&emsp;&emsp;通常，我们在使用 ECDSA 和 Schnorr签名时，我们对消息(*签名原文*)进行哈希处理，并在签名时中将此哈希值当作数字来处理。对于 BLS 签名，我们需要对哈希算法稍微的进行修改，直接将哈希值映射到椭圆曲线上。最简单的方法是像往常一样对消息进行哈希操作，并将结果视为一个点的 x 坐标。椭圆曲线（就像我们在比特币中使用的曲线）通常有大约 2²⁵⁶个 点，而SHA-256 哈希算法的结果也正好是 256 位的结果。但是，对于每个有效的 x 坐标，在曲线上都有两个具有正负 y 坐标的点（因为如果 ***(x,y)*** 在曲线上 ***y²=x³+ax+b*** 那么 ***(x,-y)*** 也在曲线上）。这意味着我们的哈希运算有大约 50% 的概率会找到有相同 x 坐标的两个点，而另 50% 的概率将找不到对应的点。
![](../../../../../../images/hash2curve.png)
<center><small><i>在模23的有限域上定义的椭圆曲线 y²=x³+7 哈希到点的简易示例。所有 x 坐标中只有一半有点。这里是进行第三次尝试就成功了。</i></small></center>   
&emsp;&emsp;要为任意消息找到一个点，我们可以通过向消息附加一个数字，并在失败时递增它来尝试进行多次哈希运算。如果 ***hash(m||0)*** 没有找到一个点，我们继续尝试 ***hash(m||1)***、***hash(m||2)*** 等等，直到我们最终得到一个匹配的点。然后我们选择两个对应点之一，比如说y较小的那个，我们就完成哈希到点的过程。
#### **曲线配对**
&emsp;&emsp;我们需要的另一个事是一个非常特殊的函数，它在一条曲线（或两条不同的曲线）上获取两个点 ***P*** 和 ***Q*** 并将它们映射到一个数字：
***e(P, Q) → n***  
&emsp;&emsp;我们还需要这个函数有一个重要属性。如果我们有一些秘密数字 ***x*** 和两个点 ***P*** 和 ***Q***，无论我们将哪个点乘以这个数字，我们都应该得到相同的结果：
***e(x×P, Q) = e(P, x×Q)***  
&emsp;&emsp;基本上，我们需要等式能够在不改变结果的情况下交换两个点乘数的参数。更一般地说，所有这些公式变换应该得出相同的结果：
***e(a×P, b×Q) = e(P, ab×Q) = e(ab×P, Q) = e(P, Q)^(ab)***  
&emsp;&emsp;我不打算描述这个函数究竟是如何工作的。基础数学非常复杂，如果你想了解所有令人讨厌的细节，我建议你阅读[这篇文章](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)和其中的参考资料。如果你想更深入——这篇[论文](https://crypto.stanford.edu/pbc/thesis.pdf)完全是关于曲线配对的。现在我们只需要了解这样的函数存在并且它们不会透露任何关于我们的秘密数字 x 的信息。  
&emsp;&emsp;一个重要的注意事项是我们不能在这里使用任何椭圆曲线（特别是标准比特币曲线 secp256k1 ，它不起作用）。为了使这个功能高效和安全，我们必须使用“配对友好(*pairing-friendly*)”曲线家庭中非常特殊的曲线。  
#### **BLS签名方案**
&emsp;&emsp;现在，我们拥有了构建 BLS 签名所需的一切。像往常一样，我们的私钥是某个秘密数字 ***pk***，我们的公钥是 ***P = pk×G***，我们正在签名的消息是 ***m***。  
&emsp;&emsp;为了计算签名，我们将我们的消息哈希到曲线 ***H(m)*** 并将结果点乘以我们的私钥：***S = pk×H(m)***。这就完成了！没有别的了——没有随机数，没有额外的操作，只是一个哈希值乘以私钥！我们的签名只是曲线上的一个点，压缩并序列化之后仅占用 33 个字节！
![](../../../../../../images/BLS-sign.png)
<center><small><i>BLS 签名生成示意图。为了获得签名，我们将消息的哈希值乘以私钥。</i></small></center>  
&emsp;&emsp;要验证此签名，可以计算我们的公钥 P 并检查：
***e(P, H(m)) = e(G, S)***
因为我们上面介绍的关于曲线配对的优点,所以这个公式是成立的。
***e(P, H(m)) = e(pk×G, H(m)) = e(G, pk×H(m)) = e(G, S)***
![](../../../../../../images/BLS-verify.png)
<center><small><i>BLS验签示意图。我们只需要检查公钥和消息哈希计算的数字与曲线基点和签名结果计算的数字是否相同。</i></small></center>  
&emsp;&emsp;这个签名方案既漂亮又简单，同时它还有几个非常好的特性，尤其是对于比特币来说。
### **签名聚合**
&emsp;&emsp;现在，让我们来将区块中的所有签名聚合在一起！假设，我们有一个包含 1000 笔交易的区块，每笔交易都包含签名 ***Si***、公钥 ***Pi*** 和签名 ***mi*** 的消息。如果我们可以将它们聚合成一个签名，我们为什么还要存储所有签名呢？毕竟，我们只关心区块中的所有签名是否有效。聚合签名将是区块中所有签名的总和：
***S = S1+S2+…+S1000***  
要验证该区块是否有效，我们需要检查以下等式是否成立：  
***e(G, S) = e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))***  
如果你仔细的观察一下，你就会发现事实上它是成立的：  
***e(G, S)  
=e(G, S1+S2+…+S1000)  
=e(G, S1)⋅e(G, S2)⋅…⋅e(G, S1000)  
=e(G, pk1×H(m1))⋅…⋅e(G, pk1000×H(m1000))  
=e(pk1×G, H(m1))⋅…⋅e(pk1000×G, H(m1000))  
=e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))***  
&emsp;&emsp;我们仍然需要知道所有的公钥并需要计算 1001 个配对函数，但至少，该区块中的所有签名只占用了 33 个字节。签名的聚合可以由矿工完成，这会在区块中节省大量空间。
### **密钥聚合与n-n的多重签名**
&emsp;&emsp;如果我们使用多重签名，我们将使用不同的密钥签署同一个交易。在这种情况下，我们可以像在 Schnorr 中那样进行密钥聚合，我们将所有签名和所有密钥聚合成为一对密钥和一个签名。让我们采用一个常见的 3-of-3 多重签名方案来说明（在实际使用中，可以是任意数字的其他组合）。  
聚合它们有一个简单的方法，就是将所有签名和所有密钥加在一起。结果将是签名 ***S=S1+S2+S3*** 和密钥 ***P=P1+P2+P3***。很容易看出，同样的验证方程仍然有效：  
***e(G, S) = e(P, H(m))***  
我们可以这样推导：  
***e(G, S)  
=e(G, S1+S2+S3)  
=e(G, (pk1+pk2+pk3)×H(m))  
=e((pk1+pk2+pk3)×G, H(m))  
=e(P1+P2+P3, H(m))  
=e(P, H(m))***  
&emsp;&emsp;就像在 Schnorr签名中一样，我们需要保护自己免受恶意密钥攻击。我们可以通过要求每个合作签名者证明他们拥有公钥对应的私钥（通过签署他们的公钥）来做到这一点，或者我们可以在方案中添加一些非线性的元素并使得恶意密钥攻击变得无法成功。我们不只是将所有密钥和签名直接进行相加，而是将它们乘以某个数字，然后再相加：  
***S = a1×S1+a2×S2+a3×S3***  
***P = a1×P1+a2×P2+a3×P3***  
这里面签名和密钥乘以的系数是根据所有合作签名者的公钥确定性地计算出来的：  
***ai = hash(Pi, {P1,P2,P3})***  
&emsp;&emsp;例如，它可以用签名者的公钥和所有合作签名者的公钥集合前后串联来进行计算：  
***ai = hash(Pi||P1||P2||P3)***  
&emsp;&emsp;同样的验证方程仍然有效。证明中会有额外的系数 ***ai***，但总体逻辑是一样的。  
&emsp;&emsp;这个方案的好处是你不需要在设备之间进行多次通信。你只需要知道谁是合作签名者就可以了。这比 Schnorr 签名的 3 轮多重签名方案要简单得多。它也不依赖于任何随机性，它是一种完全确定性的签名算法。
### **分组多重签名方案（m-n的多重签名）**
&emsp;&emsp;通常，我们不想使用 n-of-n 多重签名方案，我们更喜欢使用 m-of-n，比如 2-of-3。我们不想仅仅因为丢失了一把密钥就失去了所有的资产。在这种情况下使用密钥聚合会很不错。使用 Schnorr 签名时，我们可以通过使用公钥的默克尔树来做到这一点。虽然这不是最有效的方法，但它是可行的。不幸的是，一旦你的m和n值比较大，默克尔树的大小就会呈指数级增长。  
&emsp;&emsp;当使用 BLS 签名时还有另一种方法，但它并不是那么简单。我们需要一个普通的哈希函数，它输出一个数字——***hash(x)***，以及一个哈希到点的哈希函数——***H(x)***。当我们决定使用BLS的多重签名时，我们还需要一个“初始设置”阶段，但在此之后我们就不再需要进行通信了——我们只需要签名操作就可以签署任何数量的交易。  
&emsp;&emsp;我将再次使用一个简单的示例来进行说明，我们将构建一个 2-of-3 的多重签名，其中密钥存储在 3 个不同的设备上。使用这个方案，m和n的取值范围可以扩大到任意值。
#### **初始设置阶段**
&emsp;&emsp;我们的每个设备都有一个签名者编号 **i = 1,2,3**，代表着它在这个合作签名组中的位置，一个私钥 ***pki*** 和一个相应的公钥 ***Pi = pki×G***。我们用和前面完全相同的方式计算聚合公钥：  

***P = a1×P1+a2×P2+a3×P3, ai = hash(Pi, {P1,P2,P3})***  

&emsp;&emsp;然后每个设备都需要将数字 ***i*** 与我们的聚合公钥一起进行签名操作（对于每个***i***都要这么做），聚合这些签名并将结果保存在相应的设备上：  

***MKi = (a1⋅pk1)×H(P, i)+(a2⋅pk2)×H(P, i)+(a3⋅pk3)×H(P, i)***  

&emsp;&emsp;我们将这个签名称为“成员密钥”(*membership key*)，稍后我们将使用它进行签名。每个成员密钥都是消息 ***H(P,i)*** 的有效 ***n-of-n*** 签名，这意味着：  

***e(G, MKi)=e(P, H(P,i))***

&emsp;&emsp;记住这个等式，我们稍后会用到它。它将用于证明我们是多重签名方案的有效参与者。

#### **签名阶段**
&emsp;&emsp;现在假设我们只想使用密钥 ***pk1*** 和 ***pk3*** 签署交易。我们将生成两个签名 S1 和 S3： 

***S1 = pk1×H(P, m)+MK1, S3=pk3×H(P, m)+MK3***

&emsp;&emsp;并将它们相加以获得一个单个签名和密钥：  

***(S’, P’) = (S1+S3, P1+P3)***

&emsp;&emsp;我在这里写成 ***P'*** 和 ***S'*** 是为了强调这个密钥和签名仅由所有签名者的一个子集签名，它与作为所有签名者都参与计算的聚合密钥的 ***P*** 不同。要验证这个 ***2-of-3*** 签名，我们需要检查:  

***e(G, S’) = e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))***  

我们记得成员密钥 ***MK1*** 和 ***MK3*** 是由聚合密钥 ***P*** 对消息 ***H(P, 1)*** 和 ***H(P, 3)*** 进行签名的有效签名，因此：
***e(G, S’)  
=e(G, S1+S3)  
=e(G, pk1×H(P, m)+pk3×H(P, m)+MK1+MK3)  
=e(G, pk1×H(P, m)+pk3×H(P, m))⋅e(G, MK1+MK3)  
=e(pk1×G+pk3×G, H(P, m))⋅e(P, H(P, 1)+H(P, 3))  
=e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))***  
这就完成了。比 n-of-n 复杂一点，但仍然是可以理解的。
####  **可能的实现**
&emsp;&emsp;为了实现这个多重签名方案，假设我们需要向与聚合公钥 ***P*** 对应的地址转帐，并要求至少需要两个签名。在比特币脚本中，我们的锁定脚本可能如下所示：
***OP_2 <P> OP_CHECK_BLS_MULTISIG***  
&emsp;&emsp;这里的***OP_2***标识出我们需要两个密钥来签署交易。我们没有说总共有 3 个签名者，所以不能说它是 2-of-3 还是 2-of-100 的多重签名地址。我们后续也不会透露这些信息。  
&emsp;&emsp;为了花费这个output，我们需要提供一个密钥 ***P'***、签名 ***S'*** 和参与签名者的索引——在我们的例子中是数字 1 和 3。解锁脚本可能如下所示：
***OP_1 OP_3 <P’> <S’>***  
&emsp;&emsp;组合这些脚本为我们提供了所有必要的信息。从 ***OP_1*** 和 ***OP_3*** 我们知道我们需要计算哈希 ***H(P, 1)*** 和 ***H(P, 3)***，然后我们就拥有了验证交易签名所需要的一切。  
&emsp;&emsp;这意味着对于任意 ***m*** 和 ***n*** 来说我们只需要：  
* 锁定脚本中的一个全员聚合公钥 ***P***
* 参与签名者的一个聚合公钥 ***P'***
* 一个聚合签名 ***S'***
* ***m***的个数和签名者的索引  

它非常的紧凑和漂亮!  
&emsp;&emsp;这里只有一件事我不太喜欢……通常我们只使用一次性地址——我们使用像 BIP32 这样的密钥派生规范来生成新的私钥和地址。但是对于BLS多签来说，每一组新的私钥，我们都需要重新计算一组新的成员密钥。有一种方法可以无需每次都运行初始设置阶段，那就是生成一大堆密钥，再取其中的 1000 个并获取相应的成员密钥。毕竟，它们只有 32 字节长。然后，只有在使用了所有 1000 个地址后，我们才需要再次运行初始设置阶段。
### **一些缺点**
&emsp;&emsp;正如这里的评论和twitter上所指出的，我跳过了一个重要部分，让你认为 BLS 签名是完美的。但他们不是。非常感谢提出这个问题！  
&emsp;&emsp;曲线配对很难。我完全跳过了这个部分，我们可能会认为我们的魔法函数 ***e(P, Q)*** 是高效且安全的，但这并不完全正确。  
#### **曲线配对并不高效**
&emsp;&emsp;BLS 签名验证比 ECDSA 难一个数量级。包含 1000 个交易的整个区块的签名聚合仍然需要计算 1000 个配对，因此验证一个区块中的一个微小签名可能比验证 1000 个单独的 ECDSA 签名需要更长的时间。我们在这里实现的唯一好处是我们可以在区块中容纳更多的交易，因为聚合签名仅需要约 32 个字节。  
&emsp;&emsp;与 BLS 不同，Schnorr 签名非常的高效——它们可以一起验证，而且这个过程比 ECDSA 效率高 3 倍。这样的话，问题就来了：到底什么对我们更重要（空间还是时间）？
#### **安全证明更困难**  
&emsp;&emsp;曲线配对函数很复杂，如果我们使用的不够小心，它可能会成为我们的敌人。一方面，我们希望配对更高效，以更快地验证签名，另一方面，我们不想泄露任何关于我们的密钥的信息。这两个要求相互冲突，我们需要非常小心地选择适合配对的曲线。  
&emsp;&emsp;事实上，椭圆曲线加密系统确实存在一种攻击，被称为 [MOV攻击](https://sci-hub.tw/https://ieeexplore.ieee.org/document/259647/)（以 Menezes、Okamoto 和 Vanstone 命名），它通过利用我们的神奇的配对函数来降低系统的安全性。所以我们在这里真的需要小心。

### **结论**
&emsp;&emsp;BLS 签名很棒——我们可以将一个区块中的所有签名组合成一个签名，我们可以使用密钥聚合和 m-of-n 多重签名方案而无需额外进行多次通信，我们不需要依赖随机数生成器，而且该方案本身看起来非常漂亮和简单。但是它还有改进的空间——标准化和性能优化，这一切都需要一些时间。但我希望在未来某个时候这个签名算法会变得足够好，可以包含在比特币协议中，我们将能够使用所有这些优秀的特性，以及更小、更可聚合的签名。  

&emsp;&emsp;我很高兴看到第一作者 Dan Boneh 致力于加密货币。他是一位伟大的密码学家，他的 [coursera 密码课程](https://www.coursera.org/learn/crypto)非常出色。我也推荐他写的密码学的[书](http://toc.cryptobook.us/)，尽管它还没有完成。我相信在不久的将来，我们会看到他和他的团队带来许多有趣的方案和协议改进。

本应翻译自：
https://medium.com/cryptoadvance/bls-signatures-better-than-schnorr-5a7fe30ea716